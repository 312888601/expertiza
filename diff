diff --git a/app/models/assignment.rb b/app/models/assignment.rb
index 5bf447a..654a7fb 100644
--- a/app/models/assignment.rb
+++ b/app/models/assignment.rb
@@ -409,24 +409,71 @@ class Assignment < ActiveRecord::Base
     review_questionnaire_id
   end
 
-  def self.export_details(csv, parent_id, detail_options)
-    @assignment = Assignment.find(parent_id)
+  def csv_row(answer)
+    tcsv = []
+    @response = Response.find_by_id(answer.response_id)
+    ans = ResponseMap.find_by_id(@response.map_id)
+
+    @reviewee = Team.find_by_id(ans.reviewee_id)
+    if @reviewee.nil?
+      @reviewee = Participant.find_by_id(ans.reviewee_id).user
+    end
 
-    @answers = {} # Contains all answer objects for this assignment
+    reviewer = Participant.find_by_id(ans.reviewer_id).user
 
-    # Find all unique response types
-    @uniq_response_type = ResponseMap.uniq.pluck(:type)
-    # Find all unique round numbers
-    @uniq_rounds = Response.uniq.pluck(:round)
+    if @reviewee.nil?
+      tcsv << ' '
+    elsif detail_options['team_id'] == 'true'
+      tcsv << @reviewee.id
+    end
 
-    # create the nested hash that holds all the answers organized by round # and response type
-    @uniq_rounds.each do |round_num|
-      @answers[round_num] = {}
-      @uniq_response_type.each do |res_type|
-        @answers[round_num][res_type] = []
-      end
+    if @reviewee.nil?
+      tcsv << ' '
+    elsif detail_options['team_name'] == 'true'
+      tcsv << @reviewee.name
+    end
+
+    if reviewer.nil?
+      tcsv << ' '
+    elsif detail_options['reviewer'] == 'true'
+      tcsv << reviewer.name
+    end
+
+    if answer.question.txt.nil?
+      tcsv << ' '
+    elsif detail_options['question'] == 'true'
+      tcsv << answer.question.txt
     end
 
+    if answer.question.id.nil?
+      tcsv << ' '
+    elsif detail_options['question_id'] == 'true'
+      tcsv << answer.question.id
+    end
+
+    if answer.id.nil?
+      tcsv << ' '
+    elsif detail_options['comment_id'] == 'true'
+      tcsv << answer.id
+    end
+
+    if answer.comments.nil?
+      tcsv << ' '
+    elsif detail_options['comments'] == 'true'
+      tcsv << answer.comments
+    end
+
+    if answer.answer.nil?
+      tcsv << ' '
+    elsif detail_options['score'] == 'true'
+      tcsv << answer.answer
+    end
+
+    return tcsv
+
+  end
+
+  def generate_answer
     # get all response maps for this assignment
     @response_maps_for_assignment = ResponseMap.find_by_sql(["SELECT * FROM response_maps WHERE reviewed_object_id = #{@assignment.id}"])
     
@@ -440,17 +487,13 @@ class Assignment < ActiveRecord::Base
         @answer.each do |ans|
           @answers[res_map.round][map.type].push(ans)
         end
-      
       end
-      
     end
+  end
 
-    # Loop through each round and response type and construct a new row to be pushed in CSV
-    @uniq_rounds.each do |round_num|
-      
-      @uniq_response_type.each do |res_type|
-        
-        if !@answers[round_num][res_type].empty?
+  def check_empty_rounds(round_num, res_type)
+
+    if !@answers[round_num][res_type].empty?
           if round_num.nil?
             round_type = "Round Nill - " + res_type
           else 
@@ -459,69 +502,39 @@ class Assignment < ActiveRecord::Base
           
           csv << [round_type, '---', '---', '---', '---', '---', '---']
         end
+  end
 
-        @answers[round_num][res_type].each do |answer|
-          tcsv = []
-
-          @response = Response.find_by_id(answer.response_id)
-          ans = ResponseMap.find_by_id(@response.map_id)
-
-          @reviewee = Team.find_by_id(ans.reviewee_id)
-          if @reviewee.nil?
-            @reviewee = Participant.find_by_id(ans.reviewee_id).user
-          end
-
-          reviewer = Participant.find_by_id(ans.reviewer_id).user
-
-          if @reviewee.nil?
-            tcsv << ' '
-          elsif detail_options['team_id'] == 'true'
-            tcsv << @reviewee.id
-          end
+  def self.export_details(csv, parent_id, detail_options)
+    @assignment = Assignment.find(parent_id)
 
-          if @reviewee.nil?
-            tcsv << ' '
-          elsif detail_options['team_name'] == 'true'
-            tcsv << @reviewee.name
-          end
+    @answers = {} # Contains all answer objects for this assignment
 
-          if reviewer.nil?
-            tcsv << ' '
-          elsif detail_options['reviewer'] == 'true'
-            tcsv << reviewer.name
-          end
+    # Find all unique response types
+    @uniq_response_type = ResponseMap.uniq.pluck(:type)
+    # Find all unique round numbers
+    @uniq_rounds = Response.uniq.pluck(:round)
 
-          if answer.question.txt.nil?
-            tcsv << ' '
-          elsif detail_options['question'] == 'true'
-            tcsv << answer.question.txt
-          end
+    # create the nested hash that holds all the answers organized by round # and response type
+    @uniq_rounds.each do |round_num|
+      @answers[round_num] = {}
+      @uniq_response_type.each do |res_type|
+        @answers[round_num][res_type] = []
+      end
+    end
 
-          if answer.question.id.nil?
-            tcsv << ' '
-          elsif detail_options['question_id'] == 'true'
-            tcsv << answer.question.id
-          end
+    generate_answer
 
-          if answer.id.nil?
-            tcsv << ' '
-          elsif detail_options['comment_id'] == 'true'
-            tcsv << answer.id
-          end
+    # Loop through each round and response type and construct a new row to be pushed in CSV
+    @uniq_rounds.each do |round_num|
+      
+      @uniq_response_type.each do |res_type|
+        
+        check_empty_rounds(round_num, res_type)
 
-          if answer.comments.nil?
-            tcsv << ' '
-          elsif detail_options['comments'] == 'true'
-            tcsv << answer.comments
-          end
+        @answers[round_num][res_type].each do |answer|
 
-          if answer.answer.nil?
-            tcsv << ' '
-          elsif detail_options['score'] == 'true'
-            tcsv << answer.answer
-          end
+          csv << csv_row(answer)
 
-          csv << tcsv
         end
       end
     end
